generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "mysql"
  url      = env("DATABASE_URL")
}

model User {
  id            Int                    @id @default(autoincrement())
  email         String                 @unique
  username      String                 @unique
  password_hash String
  currency      String                 @default("USD") // Preferred currency
  created_at    DateTime               @default(now())
  accounts      Account[]
  transactions  Transaction[]
  templates     Template[]
  categories    Category[]
  budgets       Budget[]
  recurring     RecurringTransaction[]
  refreshTokens RefreshToken[]
  loginHistory  LoginHistory[]
  auditLogs     AuditLog[]
}

model RefreshToken {
  id        String   @id @default(uuid())
  token     String   @unique
  userId    Int
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  expiresAt DateTime
  createdAt DateTime @default(now())
}

model LoginHistory {
  id         Int      @id @default(autoincrement())
  userId     Int
  user       User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  ipAddress  String
  userAgent  String?
  device     String?  // Parsed device type: "Desktop", "Mobile", "Tablet", etc.
  browser    String?  // Parsed browser name
  os         String?  // Parsed OS name
  country    String?  // Geo-IP country (optional)
  city       String?  // Geo-IP city (optional)
  success    Boolean  @default(true)  // Was login successful?
  createdAt  DateTime @default(now())

  @@index([userId])
  @@index([createdAt])
  @@index([ipAddress])
}

model AuditLog {
  id         Int      @id @default(autoincrement())
  userId     Int?
  user       User?    @relation(fields: [userId], references: [id], onDelete: SetNull)
  action     String   // e.g., "transaction.create", "account.delete", "transfer.create"
  entityType String   // e.g., "transaction", "account", "budget"
  entityId   Int?     // ID of the affected entity
  oldValue   String?  @db.Text // JSON string of previous state
  newValue   String?  @db.Text // JSON string of new state
  ipAddress  String?
  userAgent  String?
  metadata   String?  @db.Text // Additional context as JSON
  createdAt  DateTime @default(now())

  @@index([userId])
  @@index([action])
  @@index([entityType])
  @@index([createdAt])
}

model Account {
  id                   Int                    @id @default(autoincrement())
  name                 String
  type                 String // "normal" | "savings"
  color                String? // UI color helper
  currency             String                 @default("USD")
  balance              Int                    @default(0)
  user_id              Int
  user                 User                   @relation(fields: [user_id], references: [id], onDelete: Cascade)
  created_at           DateTime               @default(now())
  transactions         Transaction[]
  templates            Template[]
  RecurringTransaction RecurringTransaction[]

  @@index([user_id])
}

model Category {
  id           Int                    @id @default(autoincrement())
  name         String
  type         String // "income" | "expense"
  color        String?
  icon         String?
  user_id      Int
  user         User                   @relation(fields: [user_id], references: [id], onDelete: Cascade)
  created_at   DateTime               @default(now())
  transactions Transaction[]
  budget       Budget?
  recurring    RecurringTransaction[]
  templates    Template[]

  @@index([user_id])
}

model Transaction {
  id          Int       @id @default(autoincrement())
  amount      Int
  description String
  type        String // "income" | "expense"
  account_id  Int
  account     Account   @relation(fields: [account_id], references: [id], onDelete: Cascade)
  user_id     Int
  user        User      @relation(fields: [user_id], references: [id], onDelete: Cascade)
  category_id Int?
  category    Category? @relation(fields: [category_id], references: [id])
  transfer_id String? // UUID to link two transactions (debit/credit) for transfers
  created_at  DateTime  @default(now())

  @@index([user_id])
  @@index([account_id])
  @@index([created_at])
}

model Template {
  id                 Int      @id @default(autoincrement())
  name               String
  amount             Int
  description        String?
  color              String?
  icon_name          String? // Store icon name string
  default_account_id Int?
  default_account    Account? @relation(fields: [default_account_id], references: [id])
  category_id        Int?
  category           Category? @relation(fields: [category_id], references: [id])
  type               String   @default("expense")
  user_id            Int
  user               User     @relation(fields: [user_id], references: [id], onDelete: Cascade)
  created_at         DateTime @default(now())
}

model Budget {
  id          Int      @id @default(autoincrement())
  amount      Int
  period      String   @default("monthly")
  category_id Int?     @unique
  user_id     Int
  created_at  DateTime @default(now())
  updated_at  DateTime @updatedAt

  category Category? @relation(fields: [category_id], references: [id])
  user     User      @relation(fields: [user_id], references: [id], onDelete: Cascade)
}

model RecurringTransaction {
  id            Int      @id @default(autoincrement())
  amount        Int
  description   String
  type          String // "income" | "expense"
  interval      String // "weekly" | "monthly" | "yearly"
  next_run_date DateTime
  active        Boolean  @default(true)
  category_id   Int?
  account_id    Int
  user_id       Int
  created_at    DateTime @default(now())
  updated_at    DateTime @updatedAt

  category Category? @relation(fields: [category_id], references: [id])
  account  Account   @relation(fields: [account_id], references: [id])
  user     User      @relation(fields: [user_id], references: [id], onDelete: Cascade)
}

model ExchangeRate {
  id        Int      @id @default(autoincrement())
  currency  String   @unique // e.g., "EUR"
  rate      Float    // Exchange rate relative to base currency (USD)
  updatedAt DateTime @updatedAt
}
